==========================
============oops==========
==========================
Topics
==========================
Inheritance 
Encapsulation
Polymorphism
Abstraction 
=========================
__new__ | __init__
self key 
constructer
destructer
super key --> super().__init__() / BaseClassName.__init__(self)
Object
Class
method
variables --> class variables/static variables | class method/ststic method 
function
method overloading / method over riding 


=======================
Inheritance :
=======================
1. Inheritance enable us to define a class that takes all the functionality from parent class and allows us to add more.
2. Inheritance is a powerful feature in object oriented programming.
3. class BaseClass:
  Body of base class
class DerivedClass(BaseClass):
  Body of derived class
4. Derived class inherits features from the base class, adding new features to it. This results into re-usability of code.
5. It provides reusability of a code. We don’t have to write the same code again and again. Also, it allows us to
add more features to a class without modifying it.
6. It is transitive in nature, which means that if class B inherits from another class A, then all the subclasses of B would automatically inherit from class A.
7. A process of using details from a new class without modifying existing class

Multiple Inheritance in Python :
-------------------------------
1. In multiple inheritance, the features of all the base classes are inherited into the derived class
2. class Base1:
    pass
class Base2:
    pass
class MultiDerived(Base1, Base2):
    pass
Here, MultiDerived is derived from classes Base1 and Base2.
3. In the multiple inheritance scenario, any specified attribute is searched first in the current class. If not found, the search continues into parent classes in depth-first, left-right fashion without searching same class twice.

Multilevel Inheritance in Python :
----------------------------------
1. On the other hand, we can also inherit form a derived class. This is called multilevel inheritance. 
It can be of any depth in Python.
2. In multilevel inheritance, features of the base class and the derived class is inherited into the new derived class.
3. class Base:
    pass
class Derived1(Base):
    pass
class Derived2(Derived1):
    pass

Method Resolution Order in Python:
----------------------------------
1. Every class in Python is derived from the class object. It is the most base type in Python.
2. So technically, all other class, either built-in or user-defines, are derived classes and all objects are instances of object class.
# Output: True
print(issubclass(list,object))
# Output: True
print(isinstance(5.5,object))
# Output: True
print(isinstance("Hello",object))


Encapsulation:
===============
1. In an object oriented python program, you can restrict access to methods and variables. This can prevent the data from being modified by accident and is known as encapsulation.
2. Python does not have the private keyword, unlike some other object oriented languages, but encapsulation can be done.
3. Encapsulation is a mechanism that restricts direct access to objects’ data and methods. But at the same time, it facilitates operation on that data (objects’ methods).

class Robot(object):
   def __init__(self):
      self.a = 123
      self._b = 123
      self.__c = 123

obj = Robot()
print(obj.a)
print(obj._b)
print(obj.__c)

123
123
Traceback (most recent call last):
  File "test.py", line 10, in &lt;module&gt;
    print(obj.__c)
AttributeError: 'Robot' object has no attribute '__c' 

==>A single underscore: Private variable, it should not be accessed directly. But nothing stops you from doing that (except convention).
==>A double underscore: Private variable, harder to access but still possible.

Private methods :
-----------------
We create a class Car which has two methods:  drive() and updateSoftware().
When a car object is created, it will call the private methods __updateSoftware().  
This function cannot be called on the object directly, only from within the class.

class Car:
 
    def __init__(self):
        self.__updateSoftware()
 
    def drive(self):
        print 'driving'
 
    def __updateSoftware(self):
        print 'updating software'
 redcar = Car()
redcar.drive()
#redcar.__updateSoftware()  not accesible from object.

output ->
updating software
driving
-----------------------
class Car:
 
    __maxspeed = 0
    __name = ""
 
    def __init__(self):
        self.__maxspeed = 200
        self.__name = "Supercar"
 
    def drive(self):
        print('driving. maxspeed ' + str(self.__maxspeed))
redcar = Car()
redcar.drive()
redcar.__maxspeed = 10  # will not change variable because its private
redcar.drive()

#driving. maxspeed 200
#driving. maxspeed 200

Type			Description
public methods		Accessible from anywhere
private methods		Accessible only in their own class. starts with two underscores
public variables	Accessible from anywhere
private variables	Accesible only in their own class or by a method if defined. starts with two underscores

class Person:
  def __init__(self): 
    self.name = 'Manjula'
    self.__lastname = 'Dube'
    
  def PrintName(self):
    return self.name +' ' + self.__lastname
    
#Outside class    
P = Person()
print(P.name) #Manjula
print(P.PrintName()) #Manjula Dube
print(P.__lastname) #error


class Robot(object):
   def __init__(self):
      self.__version = 22

   def getVersion(self):
      print(self.__version)

   def setVersion(self, version):
      self.__version = version

obj = Robot()
obj.getVersion()
obj.setVersion(23)
obj.getVersion()
print(obj.__version)

#22
#23
#error































































































































































































































































































































==============
© 2018 GitHub, Inc.
